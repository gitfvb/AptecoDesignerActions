

enum DSCPScope {
    Global = 0          # global
    Local = 1           # list/loca
    Transactional = 2   # Transactional
}

# DigitalChannelServiceProvider
class DCSP {

    [String]$providerName
    static [bool]$allowNewFieldCreation = $false

}


class DCSPField {

    [String] $id
    [String] $name
    [String] $label
    [String] $description
    [String] $placeholder
    [String] $dataType
    [String[]] $synonyms
    [DSCPScope] $scope = [DSCPScope]::Global
    [bool] $required = $false
    [String[]] $dependency # Dependency to other field
    [DCSPFieldChoice[]] $choices  # For selector values

    # empty default constructor needed to support hashtable constructor
    DCSPField () {
    } 

}

class DCSPFieldChoice {

    [String] $id
    [String] $label
    [String] $description
    
    # empty default constructor needed to support hashtable constructor
    DCSPFieldChoice () {
    } 

}






class EmarsysField : DCSPField {

    hidden [Emarsys]$emarsys

    EmarsysField () {
    } 

    delete() {

        # TODO [ ] check if right

        # Call emarsys
        $params = @{
            cred = $this.emarsys.cred
            uri = "$( $this.emarsys.baseUrl)field/$( $this.id )"
            method = [Microsoft.PowerShell.Commands.WebRequestMethod]::Delete
        }
        $res = Invoke-emarsys @params
        

    }

}

enum EmarsysFieldApplicationTypes {
    shorttext = 0
    longtext = 1
    largetext = 2
    date = 3
    url = 4
    numeric = 5
}

# TODO [ ] implement language code for fields

class Emarsys : DCSP {

    #-----------------------------------------------
    # PROPERTIES (can be public by default, static or hidden)
    #-----------------------------------------------

    hidden [pscredential]$cred                 # holds the username and secret
    [String]$baseUrl = "https://api.emarsys.net/api/v2/"
    [DSCPScope[]]$supportedScopes = @(
        [DSCPScope]::Global
        #[DSCPScope]::Local
    )
    
    # Override inherited properties
    [String]$providerName = "emarsys"
    static [bool]$allowNewFieldCreation = $true

    #[PSCustomObject]$defaultParams


    #-----------------------------------------------
    # CONSTRUCTORS
    #-----------------------------------------------


    # empty default constructor needed to support hashtable constructor
    Emarsys () {
        $this.init()
    } 

    Emarsys ( [String]$username, [String]$secret ) {
        $stringSecure = ConvertTo-SecureString -String ( Get-SecureToPlaintext $secret ) -AsPlainText -Force
        $this.cred = [pscredential]::new( $username, $stringSecure )
        $this.init()
    }

    Emarsys ( [String]$username, [String]$secret, [String]$baseUrl ) {
        $stringSecure = ConvertTo-SecureString -String ( Get-SecureToPlaintext $secret ) -AsPlainText -Force
        $this.cred = [pscredential]::new( $username, $stringSecure )
        $this.baseUrl = $baseUrl
        $this.init()
    }

    Emarsys ( [pscredential]$cred ) {
        $this.cred = $cred
        $this.init()
    }

    Emarsys ( [pscredential]$cred, [String]$baseUrl ) {
        $this.cred = $cred
        $this.baseUrl = $baseUrl
        $this.init()
    }


    #-----------------------------------------------
    # METHODS
    #-----------------------------------------------

    hidden [void] init () {

    }

    [PSCustomObject] getSettings () {

        $params = @{
            cred = $this.cred
            uri = "$( $this.baseUrl)settings"
        }

        $res = Invoke-emarsys @params
        return $res
  
    }

    [string] newField([String]$fieldname, [EmarsysFieldApplicationTypes]$dataType) {

        # TODO [] implement this one https://dev.emarsys.com/v2/fields/create-a-field

        $body = @{
            name = $fieldname
            application_type = $dataType # shorttext|longtext|largetext|date|url|numeric
            #string_id = "" # optional otherwise autogenerated
        }
        $bodyJson = ConvertTo-Json -InputObject $body -Depth 20

        # Call emarsys
        $params = @{
            cred = $this.cred
            uri = "$( $this.baseUrl)field"
            method = [Microsoft.PowerShell.Commands.WebRequestMethod]::Post
            $body = $bodyJson
            verbose = $true
        }
        $res = Invoke-emarsys @params

        # return the new identifier of the field
        return $res

    }

    [PSCustomObject] getFields () {

        # Call emarsys
        $params = @{
            cred = $this.cred
            uri = "$( $this.baseUrl)field"
        }
        $res = Invoke-emarsys @params
        

        # Transform result to objects
        $fields = [System.Collections.ArrayList]@()
        $res | ForEach {

            $f = $_
            
            $choice = [System.Collections.ArrayList]@()

            # list fields choices
            if ( $f.application_type -eq "singlechoice") {
                $params = @{
                    cred = $this.cred
                    uri = "$( $this.baseUrl)field/$( $f.id )/choice"
                }
                $choices = Invoke-emarsys @params
                $choices | ForEach {
                    $c = $_
                    [void]$choice.Add([DCSPFieldChoice]@{
                        "id" = $c.id
                        "label" = $c.choice
                    })
                }
                # TODO [ ] check bit_position in return data
            }

            # TODO [ ] check multiple choice which is called with /choices

            $fields.Add([EmarsysField]@{
                "emarsys" = $this
                "id" = $f.id
                "name" = $f.string_id
                "label" = $f.name
                "dataType" = $f.application_type
                #"scope" = [DSCPScope]::Global
                "choices" = $choice
            })

            $choice.Clear()

        }



        # Return the results
        return $fields
               
    }

    [PSCustomObject] getLists () {

        # https://dev.emarsys.com/v2/contact-lists/count-contacts-in-a-contact-list
        # TODO  [ ] implement as classes with create, rename, delete, count, list contacts, list contacts data, add contacts, lookup(?)

        # Call emarsys
        $params = @{
            cred = $this.cred
            uri = "$( $this.baseUrl)contactlist"
        }
        $res = Invoke-emarsys @params
        return $res

    }

    [PSCustomObject] getSources () {

        # TODO  [ ] implement as classes 

        # Call emarsys
        $params = @{
            cred = $this.cred
            uri = "$( $this.baseUrl)source"
        }
        $res = Invoke-emarsys @params
        return $res

    }

    [PSCustomObject] getEmailCampaigns () {

        # https://dev.emarsys.com/v2/contact-lists/count-contacts-in-a-contact-list
        # TODO  [ ] implement as classes with the toString-function, list tracked links, list sections, preview

        # Call emarsys
        $params = @{
            cred = $this.cred
            uri = "$( $this.baseUrl)email"
        }
        $res = Invoke-emarsys @params
        return $res

    }

    # TODO [ ] implement media database if needed

    [PSCustomObject] getConditionalTextRules () {

        # TODO  [ ] implement as classes 

        # Call emarsys
        $params = @{
            cred = $this.cred
            uri = "$( $this.baseUrl)condition"
        }
        $res = Invoke-emarsys @params
        return $res

    }

    [PSCustomObject] getEmailTemplates () {

        # TODO  [ ] implement as classes 

        # Call emarsys
        $params = @{
            cred = $this.cred
            uri = "$( $this.baseUrl)email/templates"
        }
        $res = Invoke-emarsys @params
        return $res

    }

    [PSCustomObject] getLinkCategories () {

        # TODO  [ ] implement as classes 

        # Call emarsys
        $params = @{
            cred = $this.cred
            uri = "$( $this.baseUrl)settings/linkcategories"
        }
        $res = Invoke-emarsys @params
        return $res

    }

    [PSCustomObject] getExternalEvents () {

        # TODO  [ ] implement as classes 

        # Call emarsys
        $params = @{
            cred = $this.cred
            uri = "$( $this.baseUrl)event"
        }
        $res = Invoke-emarsys @params
        return $res

    }

    [PSCustomObject] getAutomationCenterPrograms () {

        # TODO  [ ] implement as classes 

        # Call emarsys
        $params = @{
            cred = $this.cred
            uri = "$( $this.baseUrl)ac/programs"
        }
        $res = Invoke-emarsys @params
        return $res

    }

    [PSCustomObject] getAutoImportProfiles () {

        # TODO  [ ] implement as classes 

        # Call emarsys
        $params = @{
            cred = $this.cred
            uri = "$( $this.baseUrl)settings/autoimports"
        }
        $res = Invoke-emarsys @params
        return $res

    }

    [PSCustomObject] downloadContactList () {

        # TODO  [ ] implement as classes 

        # Create export
        $body = @{
            distribution_method = "local"
            contactlist = 23
            contact_fields = @(
                # field ids -> max 20 columns, exclude of 27, 28, 29, 32 and 33
            )
            delimiter = ";" # ,|;
            add_field_names_header = 1
            #language = "de"
        }

        # Call emarsys
        $params = @{
            cred = $this.cred
            uri = "$( $this.baseUrl)/email/getcontacts"
            method = [Microsoft.PowerShell.Commands.WebRequestMethod]::Post

        }
        $exportId = Invoke-emarsys @params
        
        # Check export status
        #export/{exportId}

        # Download file
        # export/{exportId}/data
        
        
        
        
        return $exportId

    }

}



function Invoke-emarsys {

    [CmdletBinding()]
    param (
         [Parameter(Mandatory=$false)][pscredential]$cred                                   # securestring containing username as user and secret as password
        ,[Parameter(Mandatory=$false)][System.Uri]$uri = "https://api.emarsys.net/api/v2/"  # default url to use
        ,[Parameter(Mandatory=$false)][Microsoft.PowerShell.Commands.WebRequestMethod] $method = [Microsoft.PowerShell.Commands.WebRequestMethod]::Get
    )
    
    begin {
        

        #-----------------------------------------------
        # AUTH
        #-----------------------------------------------

        <#

        example for header

        X-WSSE: UsernameToken
        Username="customer001",
        PasswordDigest="ZmI2ZmQ0MDIxYmQwNjcxNDkxY2RjNDNiMWExNjFkZA==",
        Nonce="d36e316282959a9ed4c89851497a717f",
        Created="2014-03-20T12:51:45Z"

        source: https://dev.emarsys.com/v2/before-you-start/authentication
        api endpoints: https://trunk-int.s.emarsys.com/api-demo/#tab-customer

        other urls
        https://dev.emarsys.com/v2/emarsys-developer-hub/what-is-the-emarsys-api
        #>

        # Extract credentials
        $secret = $cred.GetNetworkCredential().Password
        $username = $cred.UserName

        # Create nonce
        $randomStringAsHex = Get-RandomString -length 16 | Format-Hex
        $nonce = Get-StringfromByte -byteArray $randomStringAsHex.Bytes
        
        # Format date
        $date = [datetime]::UtcNow.ToString("o")

        # Create password digest
        $stringToSign = $nonce + $date + $secret
        $sha1 = Get-StringHash -inputString $stringToSign -hashName "SHA1"
        $passwordDigest = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($sha1))

        # Combine Escher XWSSE header
        $xwsseArr = [System.Collections.ArrayList]@()
        [void]$xwsseArr.Add("UsernameToken Username=""$( $username )""")
        [void]$xwsseArr.Add("PasswordDigest=""$( $passwordDigest )""")
        [void]$xwsseArr.Add("Nonce=""$( $nonce )""")
        [void]$xwsseArr.Add("Created=""$( $date )""")

        # Setup content type
        $contentType = "application/json;charset=utf-8"
        #$xwsseArr.Add("Content-type=""$( $contentType )""") # take this out possibly
        
        # Join Escher XWSSE together
        $xwsse = $xwsseArr -join ", "  
        #$xwsse


        #-----------------------------------------------
        # HEADER
        #-----------------------------------------------

        $header = @{
            "X-WSSE"=$xwsse
            "X-Requested-With"=	"XMLHttpRequest"
        }

    }
    
    process {
        
                
        $params = @{
            "Uri" = $uri
            "Method" = $method
            "Headers" = $header
            "ContentType" = $contentType
            "Verbose" = $true
        }

        $result = Invoke-RestMethod @params

    }
    
    end {
        

        if ( $result.replyCode -eq 0 <# -and $result.replyText -eq "OK" #> ) {

            $result.data

        } else {
            # Errors see here: https://dev.emarsys.com/v2/response-codes/http-400-errors
            Write-Log -message "Got back $( $result.replyText ) from call to url $( $uri ), throwing exception"
            throw [System.IO.InvalidDataException]
            
        }
    }
}